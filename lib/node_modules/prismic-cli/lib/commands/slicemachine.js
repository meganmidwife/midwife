"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const yeoman_env_1 = require("../prismic/yeoman-env");
const base_command_1 = require("../prismic/base-command");
const path = require("path");
const utils_1 = require("../utils");
const child_process_1 = require("child_process");
const lookpath_1 = require("lookpath");
const inquirer = require("inquirer");
const framework_1 = require("../utils/framework");
const globby = require('fast-glob');
const { SM_FILE } = require('sm-commons/consts');
class Slicemachine extends base_command_1.default {
    async readGeneratorsFromToRc(folder) {
        const pathToYoRc = path.join(folder, '.yo-rc.json');
        const hasYoRc = utils_1.fs.existsSync(pathToYoRc);
        if (!hasYoRc)
            return Promise.resolve([]);
        const YoRc = JSON.parse(utils_1.fs.readFileSync(pathToYoRc, 'utf-8'));
        const generatorNames = Object.keys(YoRc)
            .filter(d => d.startsWith('generator-prismic-'))
            .map(d => d.replace(/^generator-/, ''));
        return Promise.resolve(generatorNames);
    }
    async maybePromptForFrameWork(frameworksInYoRc, subGeneratorName) {
        const choices = (frameworksInYoRc.length === 0) ? (this.posibleFrameWorksForSubGeneratorAsPromtps(subGeneratorName)) : frameworksInYoRc.map(d => ({
            name: d.replace(/^prismic-/, '').replace(/:.+/, ''),
            value: d.replace(/:.+/, ''),
        }));
        return inquirer.prompt({
            type: 'list',
            choices,
            name: 'framework',
            message: 'Which framework to use',
        }).then(res => res.framework);
    }
    posibleFrameWorksForSubGeneratorAsPromtps(subGeneratorName) {
        const generatorsWithSubGenerators = yeoman_env_1.filterMetaFor(yeoman_env_1.meta, subGeneratorName);
        return Object.values(generatorsWithSubGenerators).map(d => {
            const name = d.namespace.replace(/^prismic-/, '').replace(/:.+/, '');
            const value = d.namespace.replace(/:.+/, '');
            return { name, value };
        });
    }
    async runSubGenerator(name, folder, opts) {
        return this.readGeneratorsFromToRc(folder)
            .then(res => {
            if (res.length === 0 || res.length > 1)
                return this.maybePromptForFrameWork(res, name);
            return res[0];
        })
            .then(framework => {
            const setup = `${framework}:${name}`;
            return this.envRun(setup, opts);
        });
    }
    async handleSetup(folder, opts) {
        return this.runSubGenerator('slicemachine', folder, opts);
    }
    async handleCreateSlice(folder, opts) {
        return this.runSubGenerator('create-slice', folder, opts);
    }
    async handleStorybook(folder, opts) {
        return this.runSubGenerator('storybook', folder, opts);
    }
    async envRun(generatorName, options) {
        // @ts-expect-error
        return yeoman_env_1.default.run(generatorName, options);
    }
    async run() {
        const { flags } = this.parse(Slicemachine);
        const folder = flags.folder || process.cwd();
        const opts = Object.assign(Object.assign({}, flags), { prismic: this.prismic, path: folder, existingRepo: flags['existing-repo'] || false });
        if (flags['create-slice']) {
            return this.handleCreateSlice(folder, opts);
        }
        if (flags['add-storybook']) {
            return this.handleStorybook(folder, opts);
        }
        if (flags.setup) {
            const isAuthenticated = await this.prismic.isAuthenticated();
            if (!isAuthenticated) {
                await this.login();
            }
            const domain = await this.validateDomain(flags.domain, opts.existingRepo);
            return this.handleSetup(folder, Object.assign(Object.assign({}, opts), { domain }));
        }
        if (flags.list) {
            const pathToSMFile = path.join(folder, SM_FILE);
            if (utils_1.fs.existsSync(pathToSMFile) === false) {
                this.error(`Could not find ${SM_FILE} at: ${pathToSMFile}`);
            }
            return utils_1.fs.readFile(pathToSMFile, 'utf-8')
                .then(JSON.parse)
                .then(json => json.libraries || [])
                .then((libs) => {
                libs.forEach((lib) => {
                    const isLocal = lib.startsWith('@/') || lib.startsWith('~') || lib.startsWith('/');
                    const pathToSlices = path.posix.join(folder, isLocal ? '.' : 'node_modules', isLocal ? lib.substring(1, lib.length) : lib, '**', 'model.json');
                    const pathToModels = globby.sync(pathToSlices);
                    const names = pathToModels.map(pathToModel => {
                        const dir = path.dirname(pathToModel);
                        const dirs = dir.split(path.sep);
                        return dirs[dirs.length - 1];
                    });
                    this.log(lib);
                    names.forEach(name => this.log('\t' + name));
                });
            })
                .catch(this.error);
        }
        if (flags.bootstrap) {
            return this.handleBootStrap(folder, flags['existing-repo'], flags.domain);
        }
        if (flags.develop) {
            const isAuthenticated = await this.prismic.isAuthenticated();
            if (!isAuthenticated)
                await this.login();
            this.checkIsInASlicemachineProject();
            const hasYarn = await lookpath_1.lookpath('yarn');
            const usingYarn = utils_1.fs.existsSync(path.join(process.cwd(), 'yarn.lock'));
            const pm = hasYarn && usingYarn ? 'yarn' : 'npm run';
            return child_process_1.execSync(`${pm} slicemachine`, { stdio: 'inherit' });
        }
        if (!flags['create-slice'] && !flags['add-storybook'] && !flags.setup && !flags.list) {
            return this._help();
        }
    }
    async handleBootStrap(folder, existingRepo = false, maybeDomain) {
        const smFilePath = path.join(folder, SM_FILE);
        const pkgJsonPath = path.join(folder, 'package.json');
        const hasPackageJson = utils_1.fs.existsSync(pkgJsonPath);
        const packageJson = hasPackageJson ? JSON.parse(utils_1.fs.readFileSync(pkgJsonPath, 'utf-8')) : {};
        if (utils_1.fs.existsSync(smFilePath) === false) {
            return this.warn(`${SM_FILE} file not found in: ${smFilePath}`);
        }
        const isAuthenticated = await this.prismic.isAuthenticated();
        if (!isAuthenticated) {
            await this.login();
        }
        const domain = await this.validateDomain(maybeDomain, existingRepo);
        const framework = await framework_1.detect(packageJson) || '';
        const maybeCreateRepo = () => existingRepo ? Promise.resolve({ data: domain }) : this.prismic.createRepository({ domain, framework }); /* the framework is already registered on intercom, default value is '' for wroom */
        return maybeCreateRepo().then(res => {
            const url = new URL(this.prismic.base);
            url.hostname = `${res.data}.${url.hostname}`;
            return this.log(`Your Slice Machine repository was successfully created! ${url.toString()}`);
        })
            .then(() => utils_1.fs.readFile(smFilePath, 'utf-8'))
            .then(str => JSON.parse(str))
            .then(json => {
            const url = new URL(this.prismic.base);
            url.hostname = `${domain}.cdn.${url.hostname}`;
            url.pathname = 'api/v2';
            return JSON.stringify(Object.assign(Object.assign({}, json), { apiEndpoint: url.toString() }), null, 2);
        }).then(smFile => {
            return utils_1.fs.writeFile(smFilePath, smFile);
        });
    }
    checkIsInASlicemachineProject() {
        const pathToSMFile = path.join(process.cwd(), SM_FILE);
        if (utils_1.fs.existsSync(pathToSMFile) === false) {
            this.warn(`[slice-machine] Could not find ${pathToSMFile}`);
            return this.exit();
        }
        const smFile = utils_1.fs.readFileSync(pathToSMFile, 'utf-8');
        try {
            const apiEndpoint = JSON.parse(smFile).apiEndpoint;
            const url = new URL(apiEndpoint);
            return url.hostname.split('.')[0];
        }
        catch (_a) {
            this.warn(`[slice-machine] No "apiEndpoint" value found in ${pathToSMFile} .\nIn order to run this command, you need to set a Prismic repository endpoint`);
            return this.exit();
        }
    }
}
exports.default = Slicemachine;
Slicemachine.description = 'Slice Machine commands';
Slicemachine.aliases = ['sm'];
Slicemachine.flags = {
    help: command_1.flags.help({ char: 'h' }),
    force: command_1.flags.boolean({ description: 'Overwrite local files.' }),
    setup: command_1.flags.boolean({
        description: 'Setup Slice Machine in an already existing project.',
        exclusive: ['create-slice', 'add-storybook', 'list', 'bootstrap', 'develop'],
        default: false,
    }),
    domain: command_1.flags.string({
        char: 'd',
        description: 'Prismic repo to create.',
        exclusive: ['add-storybook', 'create-slice', 'sliceName', 'library', 'list', 'develop'],
    }),
    'create-slice': command_1.flags.boolean({
        description: 'Add a Slice to a Slice Machine project.',
        exclusive: ['setup', 'add-storybook', 'list', 'bootstrap', 'develop'],
        default: false,
    }),
    sliceName: command_1.flags.string({
        description: 'Name of the Slice.',
        dependsOn: ['create-slice'],
    }),
    library: command_1.flags.string({
        description: 'Name of the Slice library.',
        dependsOn: ['create-slice'],
    }),
    'add-storybook': command_1.flags.boolean({
        description: 'Add Storybook to a Slice Machine project.',
        exclusive: ['setup', 'create-slice', 'list', 'bootstrap', 'develop'],
        default: false,
    }),
    framework: command_1.flags.string({
        description: 'framework to use, see list for options',
        exclusive: ['list'],
    }),
    list: command_1.flags.boolean({
        description: 'List local Slices.',
        exclusive: ['add-storybook', 'setup', 'create-slice', 'bootstrap', 'sliceName', 'domain', 'library', 'framework', 'folder', 'skip-install', 'develop', 'existing-repo'],
        default: false,
    }),
    folder: command_1.flags.string({
        char: 'f',
        description: 'Output directory.',
    }),
    'skip-install': command_1.flags.boolean({
        description: 'Prevent npm install from running.',
        exclusive: ['create-slice', 'list', 'bootstrap'],
        default: false,
    }),
    bootstrap: command_1.flags.boolean({
        description: 'Reconfigure a Slice Machine project.',
        exclusive: ['setup', 'create-slice', 'list', 'develop'],
        default: false,
    }),
    develop: command_1.flags.boolean({
        description: 'Run Slice Machine.',
        exclusive: ['setup', 'create-slice', 'list', 'bootstrap'],
        default: false,
    }),
    customTypeEndpoint: command_1.flags.string({
        description: 'Use a different custom-type endpoint.',
        hidden: true,
        dependsOn: ['develop'],
    }),
    'existing-repo': command_1.flags.boolean({
        description: 'Connect to an existing Prismic repository when running --setup or --bootstrap',
        default: false,
        exclusive: ['add-storybook', 'create-slice', 'develop'],
    }),
};
