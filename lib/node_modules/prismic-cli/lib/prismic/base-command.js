"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const communication_1 = require("./communication");
const path = require("path");
const utils_1 = require("../utils");
const cli_ux_1 = require("cli-ux");
const path_1 = require("path");
const axios_1 = require("axios");
const inquirer = require("inquirer");
const data_dog_1 = require("../utils/data-dog");
const logDecoration_1 = require("../utils/logDecoration");
const chalk = require("chalk");
const isValidPath = require('is-valid-path');
class PrismicCommand extends command_1.Command {
    constructor(argv, config) {
        super(argv, config);
        this.prismic = new communication_1.default(config, this.debug);
        this.login = this.login.bind(this);
    }
    async catch(err) {
        this.debug(err);
        await data_dog_1.default(err, this).catch(() => this.warn('Failed to send error to datadog'));
        return super.catch(err);
    }
    async login(maybePort, maybeBase, maybeAuthUrl) {
        // used when sa session in fails
        if (this.prismic.base !== 'https://prismic.io') {
            this.warn(`current base is set to ${this.prismic.base}`);
        }
        const confirmationMessage = logDecoration_1.PRISMIC_LOG_HEADER + 'Press any key to open up the browser to login or ' + logDecoration_1.LogDecorations.FgRed + 'q' + logDecoration_1.LogDecorations.Reset + ' to exit';
        const confirmationKey = await cli_ux_1.default.prompt(confirmationMessage, { type: 'single', required: false });
        if (confirmationKey === 'q' || confirmationKey === '\u0003')
            return Promise.resolve();
        return this.prismic.login(maybePort, maybeBase, maybeAuthUrl);
    }
    async validateDomain(name, existingRepo = false) {
        const base = new URL(this.prismic.base);
        const validate = (domain) => this.prismic.validateRepositoryName(domain, existingRepo);
        const isValid = (name) ? validate(name) : Promise.reject(new Error(''));
        return isValid.catch(_ => {
            if (_.message)
                this.warn(_.message);
            return inquirer.prompt([{
                    type: 'input',
                    name: 'domain',
                    message: 'Name your prismic repository: ',
                    required: true,
                    transformer(value) {
                        const reponame = value ? chalk.cyan(value) : chalk.dim.cyan('repo-name');
                        const msg = [
                            chalk.dim(`${base.protocol}//`),
                            reponame,
                            chalk.dim(`.${base.hostname}`),
                        ];
                        return msg.join('');
                    },
                    async validate(name) {
                        const result = await validate(name);
                        return result === name || result;
                    },
                }]).then(res => res.domain).then(validate); // TODO: Find out a way to inquerer prompts in isolation.
        });
    }
    async validateFolder(name, fallback, force) {
        const folder = name || await cli_ux_1.default.prompt('project folder', { default: fallback });
        if (utils_1.fs.existsSync(folder) && !force) {
            this.warn(`Folder: ${folder} exists. use --force to overwrite`);
            return this.exit();
        }
        const isValid = isValidPath(folder);
        if (isValid === false) {
            this.warn(`Invalid path: ${folder}`);
            return this.validateFolder('', fallback, force);
        }
        return Promise.resolve(folder);
    }
    async validateTheme(maybeTheme) {
        const theme = maybeTheme || await cli_ux_1.default.prompt('Theme url').then(this.validateTheme.bind(this));
        if (this.isLocalZip(theme))
            return theme;
        if (this.isAbsoluteUrlToZip(theme))
            return theme;
        return this.maybeGitHubRepo(theme);
    }
    isLocalZip(maybePath) {
        const { ext } = path.parse(maybePath);
        if (utils_1.fs.existsSync(maybePath) && ext === '.zip') {
            return true;
        }
        return false;
    }
    isAbsoluteUrlToZip(maybeUrl) {
        try {
            const url = new URL(maybeUrl);
            const { ext } = path.parse(url.pathname);
            return (ext === '.zip');
        }
        catch (_a) {
            return false;
        }
    }
    isGithubUrl(maybeUrl) {
        try {
            const url = new URL(maybeUrl);
            return url.hostname.includes('github');
        }
        catch (_a) {
            return false;
        }
    }
    async maybeGitHubRepo(source) {
        if (this.isAbsoluteUrlToZip(source))
            return source;
        if (this.isGithubUrl(source) === false)
            return Promise.reject(new Error(`Could not guess where to find zip from ${source}`));
        const url = new URL(source);
        url.pathname = url.pathname.replace(/.git$/, '');
        const maybeRepoAndBranch = /(\/.*\/.*\/)tree\/(.*)/.exec(url.pathname);
        if (maybeRepoAndBranch) {
            const [, repo, branch] = maybeRepoAndBranch;
            url.pathname = path_1.posix.join(repo, 'archive', `${branch}.zip`);
            return url.toString();
        }
        const maybeRepo = /(\/.*\/.*)/.exec(url.pathname);
        if (!maybeRepo) {
            const error = new Error(`Could not infer github repo from ${source}`);
            return Promise.reject(error);
        }
        const [, repo] = maybeRepo;
        const master = new URL(source);
        master.pathname = path_1.posix.join(repo, 'archive', 'master.zip');
        const main = new URL(source);
        main.pathname = path_1.posix.join(repo, 'archive', 'main.zip');
        const masterUrl = master.toString();
        const mainUrl = main.toString();
        return axios_1.default.head(mainUrl)
            .then(() => mainUrl)
            .catch(async () => {
            return axios_1.default.head(masterUrl)
                .then(() => masterUrl)
                .catch((error) => {
                var _a;
                if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                    const err = new Error(`Could not resolve ${main} or ${master}`);
                    return Promise.reject(err);
                }
                return Promise.reject(error);
            });
        });
    }
}
exports.default = PrismicCommand;
