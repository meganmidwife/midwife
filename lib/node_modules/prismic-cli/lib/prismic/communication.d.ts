import { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import { IConfig } from '@oclif/config';
export interface LocalDB {
    base: string;
    cookies: string;
    oauthAccessToken?: string;
    authUrl?: string;
}
export declare type Apps = 'slicemachine' | '' | null | undefined;
interface CustomTypeBase {
    id: string;
    repeatable: string;
}
export interface CustomTypeMetaData extends CustomTypeBase {
    name: string;
    value: string;
}
export interface CustomType extends CustomTypeBase {
    name: string;
    value: object;
}
export interface SliceMachineCustomType extends CustomTypeBase {
    label: string;
    json: object;
}
export interface CreateRepositoryArgs {
    domain: string;
    framework: string;
    app?: Apps;
    customTypes?: Array<CustomType>;
    signedDocuments?: Documents;
}
export interface Document {
    [key: string]: any;
}
export interface Documents {
    signature: string;
    documents: Document;
}
export declare const DEFAULT_CONFIG: LocalDB;
export declare function createDefaultConfig(configPath: string): string;
export declare function getOrCreateConfig(configPath: string): LocalDB;
export interface AxiosInstanceOptions extends AxiosRequestConfig {
    secure?: boolean;
}
export declare function toAuthUrl(path: 'validate' | 'refreshtoken', token: string, base?: string, authUrl?: string): string;
export default class Prismic {
    configPath: string;
    base: string;
    cookies: string;
    oauthAccessToken: string | undefined;
    private authUrl?;
    debug: (...args: any[]) => void;
    constructor(config?: IConfig, debug?: (...args: any[]) => void);
    private getConfig;
    private removeConfig;
    private updateConfig;
    logout(): Promise<void>;
    setCookies(arr?: ReadonlyArray<string>): Promise<void>;
    /**
     * A custom instance of axios for communicating with prismic.io
     * @param {AxiosInstanceOptions} [options] - options passed to axios.create()
     * @returns {AxiosInstance} - axios instance.
     */
    axios(options?: AxiosInstanceOptions): AxiosInstance;
    private startServerAndOpenBrowser;
    /**
     * login in to a prismic account
     * @param {Number} [port = 5555] - the port to listen on
     * @param {String} [base = https://prismic.io] - where to make the account
     * @param {String} [maybeAuthUrl = https://auth.prismic.io] - address to call for validating and refreshing tokens
     * @returns
     */
    login(maybePort?: number, maybeBase?: string, maybeAuthUrl?: string): Promise<void>;
    private auth;
    /**
     * creates a new prismic account
     * @param {Number} [port = 5555] - the port to listen on
     * @param {String} [base = https://prismic.io] - where to make the account
     * @param {String} [maybeAuthUrl = https://auth.prismic.io] - address to call for validating and refreshing tokens
     * @returns
     */
    signUp(maybePort?: number, maybeBase?: string, maybeAuthUrl?: string): Promise<void>;
    validateSession(): Promise<AxiosResponse>;
    refreshSession(): Promise<void>;
    validateAndRefresh(): Promise<void>;
    /**
     * Checks if the user is authenticated
     * @returns {Promise} - resolves if the user is authenticated
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Promtps the user to reauthenticate
     * @returns {Promise} - resolves if successful
     */
    reAuthenticate(retries?: number): Promise<void>;
    /**
     * Validates a repository name and checks availability
     * @param {String} name - repository name
     * @param {Boolean} [existingRepo = false] expect the repository to exist
     * @returns {Promise} - rejects with errors if any, else resolves with the repository name
     */
    validateRepositoryName(name?: string, existingRepo?: boolean): Promise<string>;
    /**
     * creates a prismic repository
     * @param args
     * @returns {Promise<AxiosResponse<string>>} - AxiosResponse containing the repository name
     */
    createRepository(args: CreateRepositoryArgs): Promise<AxiosResponse<string>>;
    private createRepositoryWithCookie;
    private createRepositoryWithToken;
}
export {};
