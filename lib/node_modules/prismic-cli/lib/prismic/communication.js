"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAuthUrl = exports.getOrCreateConfig = exports.createDefaultConfig = exports.DEFAULT_CONFIG = void 0;
const utils_1 = require("../utils");
const path = require("path");
const cookie = require("../utils/cookie");
const axios_1 = require("axios");
const os = require("os");
const utils_2 = require("../utils");
const cli_ux_1 = require("cli-ux");
// Note to self it's easier to mock fs sync methods.
const server_1 = require("../utils/server");
const logDecoration_1 = require("../utils/logDecoration");
const version = require('../../package.json').version;
exports.DEFAULT_CONFIG = { base: 'https://prismic.io', cookies: '' };
function createDefaultConfig(configPath) {
    const str = JSON.stringify(exports.DEFAULT_CONFIG, null, '\t');
    utils_1.fs.writeFileSync(configPath, str, 'utf-8');
    return str;
}
exports.createDefaultConfig = createDefaultConfig;
function getOrCreateConfig(configPath) {
    try {
        const configAsString = utils_1.fs.readFileSync(configPath, 'utf-8');
        const confAsJson = utils_2.parseJsonSync(configAsString);
        return Object.assign(Object.assign({}, exports.DEFAULT_CONFIG), confAsJson);
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            // file does not exists create on and return the config in a promise.
            createDefaultConfig(configPath);
            return exports.DEFAULT_CONFIG;
        }
        throw error;
    }
}
exports.getOrCreateConfig = getOrCreateConfig;
function toAuthUrl(path, token, base = 'https://prismic.io', authUrl) {
    if (authUrl) {
        const addr = new URL(authUrl);
        addr.pathname = path;
        addr.searchParams.set('token', token);
        return addr.toString();
    } /* else if(base.includes('wroom.test')) { // TODO: remove and add param for custom auth server URL
      const url = new URL('https://<LAMBDA_DEV_ID>.execute-api.us-east-1.amazonaws.com/')
      url.pathname = `/dev/${path}`
      url.searchParams.set('token', token)
      return url.toString()
    } */
    const url = new URL(base);
    url.hostname = `auth.${url.hostname}`;
    url.pathname = path;
    url.searchParams.set('token', token);
    return url.toString();
}
exports.toAuthUrl = toAuthUrl;
/**
 * Handles communcation logic between the cli and prismic.io, should be treated as a singleton.
 * @class
 */
const noop = () => null;
class Prismic {
    constructor(config, debug) {
        const home = config && config.home ? config.home : os.homedir();
        this.configPath = path.join(home, '.prismic');
        const { base, cookies, oauthAccessToken, authUrl } = getOrCreateConfig(this.configPath);
        this.base = base;
        this.cookies = cookies;
        this.oauthAccessToken = oauthAccessToken;
        this.authUrl = authUrl;
        this.validateRepositoryName = this.validateRepositoryName.bind(this);
        this.setCookies = this.setCookies.bind(this);
        this.debug = debug || noop;
    }
    getConfig() {
        return getOrCreateConfig(this.configPath);
    }
    async removeConfig() {
        return utils_1.fs.unlink(this.configPath);
    }
    async updateConfig(data) {
        const oldConfig = this.getConfig();
        const newConfig = Object.assign(Object.assign({}, oldConfig), data);
        this.base = newConfig.base; // || 'https://prismic.io'
        this.cookies = newConfig.cookies;
        this.oauthAccessToken = newConfig.oauthAccessToken;
        this.authUrl = newConfig.authUrl;
        return utils_1.fs.writeFile(this.configPath, JSON.stringify(newConfig, null, '\t'), 'utf-8');
    }
    async logout() {
        return this.removeConfig();
    }
    async setCookies(arr = []) {
        const oldCookies = cookie.parse(this.cookies || '');
        const newCookies = arr.map(str => cookie.parse(str)).reduce((acc, curr) => {
            return Object.assign(Object.assign({}, acc), curr);
        }, {});
        const mergedCookie = Object.entries(Object.assign(Object.assign({}, oldCookies), newCookies)).map(([key, value]) => {
            return cookie.serialize(key, value);
        }).join('; ');
        return this.updateConfig({ base: this.base, cookies: mergedCookie, authUrl: this.authUrl });
    }
    /**
     * A custom instance of axios for communicating with prismic.io
     * @param {AxiosInstanceOptions} [options] - options passed to axios.create()
     * @returns {AxiosInstance} - axios instance.
     */
    axios(options) {
        const headers = Object.assign({ 'User-Agent': `prismic-cli/${version}`, Cookie: this.cookies || this.getConfig().cookies }, options === null || options === void 0 ? void 0 : options.headers);
        const opts = Object.assign(Object.assign({ baseURL: this.base, 
            // withCredentials: true,
            // xsrfCookieName: 'X_XSRF',
            adapter: require('axios/lib/adapters/http') }, options), { headers });
        // TODO: optionaly add the x_xsrf (_) parmeter to the query ie: ?_=my_x_xsrf_token
        return axios_1.default.create(opts);
    }
    async startServerAndOpenBrowser(url, base, port, logAction) {
        // tbh setCookies could be another callback if you wanted.
        return server_1.startServerAndOpenBrowser(url, base, port, logAction, this.setCookies);
    }
    /**
     * login in to a prismic account
     * @param {Number} [port = 5555] - the port to listen on
     * @param {String} [base = https://prismic.io] - where to make the account
     * @param {String} [maybeAuthUrl = https://auth.prismic.io] - address to call for validating and refreshing tokens
     * @returns
     */
    async login(maybePort = server_1.DEFAULT_PORT, maybeBase, maybeAuthUrl) {
        if (maybeBase)
            this.base = maybeBase;
        if (maybeAuthUrl)
            this.authUrl = maybeAuthUrl; // TODO: will be added upstream
        const base = maybeBase || this.base;
        const loginUrl = new URL(this.base);
        loginUrl.pathname = 'dashboard/cli/login';
        loginUrl.searchParams.append('port', maybePort.toString());
        const logAction = logDecoration_1.PRISMIC_LOG_HEADER + 'Logging in';
        return this.startServerAndOpenBrowser(loginUrl.toString(), base, maybePort, logAction);
    }
    async auth(path) {
        const token = cookie.parse(this.cookies)['prismic-auth'] || '';
        const url = toAuthUrl(path, token, this.base, this.authUrl);
        return this.axios().get(url);
    }
    /**
     * creates a new prismic account
     * @param {Number} [port = 5555] - the port to listen on
     * @param {String} [base = https://prismic.io] - where to make the account
     * @param {String} [maybeAuthUrl = https://auth.prismic.io] - address to call for validating and refreshing tokens
     * @returns
     */
    async signUp(maybePort = server_1.DEFAULT_PORT, maybeBase, maybeAuthUrl) {
        if (maybeBase)
            this.base = maybeBase;
        if (maybeAuthUrl)
            this.authUrl = maybeAuthUrl;
        const base = maybeBase || this.base;
        const signUpUrl = new URL(this.base);
        signUpUrl.pathname = 'dashboard/cli/signup';
        signUpUrl.searchParams.append('port', maybePort.toString());
        const logAction = logDecoration_1.PRISMIC_LOG_HEADER + 'Signing in';
        return this.startServerAndOpenBrowser(signUpUrl.toString(), base, maybePort, logAction);
    }
    async validateSession() {
        return this.auth('validate');
    }
    async refreshSession() {
        return this.auth('refreshtoken').then(res => {
            const token = cookie.serialize('prismic-auth', res.data);
            return this.setCookies([token]);
        });
    }
    async validateAndRefresh() {
        // TDOD: does this handle oauthAccessTokens?
        this.debug('communication.validateAndRefresh');
        // return Promise.resolve()
        return this.validateSession().then(() => this.refreshSession());
    }
    /**
     * Checks if the user is authenticated
     * @returns {Promise} - resolves if the user is authenticated
     */
    async isAuthenticated() {
        // TODO: find out if / how the authh server handles oauth tokens
        // if (this.oauthAccessToken) return Promise.resolve(true)
        if (!this.cookies)
            return Promise.resolve(false);
        const cookies = cookie.parse(this.cookies);
        if (!cookies.SESSION)
            return Promise.resolve(false);
        if (!cookies['prismic-auth'])
            return Promise.resolve(false);
        return this.validateAndRefresh()
            .then(() => true)
            .catch((error) => {
            var _a, _b, _c;
            this.debug('communication.isAuthenticated', error.message);
            const status = ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) || 100;
            if (Math.floor(status / 100) === 4) {
                return false;
            }
            if (error.response) {
                this.debug(`[${(_b = error.response) === null || _b === void 0 ? void 0 : _b.status}]: ${(_c = error.response) === null || _c === void 0 ? void 0 : _c.statusText}`);
                this.debug(error.response.data);
            }
            throw error;
        });
    }
    /**
     * Promtps the user to reauthenticate
     * @returns {Promise} - resolves if successful
     */
    async reAuthenticate(retries = 0) {
        if (retries === 0) {
            const confirmationMessage = logDecoration_1.PRISMIC_LOG_HEADER + 'Press any key to open up the browser to login or ' + logDecoration_1.LogDecorations.FgRed + 'q' + logDecoration_1.LogDecorations.Reset + ' to exit';
            const confirmationKey = await cli_ux_1.default.prompt(confirmationMessage, { type: 'single', required: false });
            if (confirmationKey === 'q' || confirmationKey === '\u0003')
                return process.exit(); // eslint-disable-line no-process-exit, unicorn/no-process-exit
        }
        return this.login().catch((error) => {
            var _a, _b, _c;
            if ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) {
                console.log(`[Error]: ${error.response.data}`);
            }
            else if ((_b = error.response) === null || _b === void 0 ? void 0 : _b.statusText) {
                console.log(`[Error]: ${error.response.statusText}`);
            }
            else {
                console.log(`[Error]: ${error.message}`);
            }
            if (((_c = error === null || error === void 0 ? void 0 : error.response) === null || _c === void 0 ? void 0 : _c.status) === 401) {
                return this.reAuthenticate(retries + 1);
            }
            throw error;
        });
    }
    /**
     * Validates a repository name and checks availability
     * @param {String} name - repository name
     * @param {Boolean} [existingRepo = false] expect the repository to exist
     * @returns {Promise} - rejects with errors if any, else resolves with the repository name
     */
    async validateRepositoryName(name, existingRepo = false) {
        if (!name)
            return Promise.reject(new Error('repository name is required'));
        const domain = name.toLocaleLowerCase().trim();
        const errors = [];
        const startsWithLetter = /^[a-z]/.test(domain);
        if (!startsWithLetter)
            errors.push('Must start with a letter.');
        const acceptedChars = /^[a-z0-9-]+$/.test(domain);
        if (!acceptedChars)
            errors.push('Must contain only letters, numbers and hyphens.');
        const fourCharactersOrMore = domain.length >= 4;
        if (!fourCharactersOrMore)
            errors.push('Must have four or more alphanumeric characters and/or hyphens.');
        const endsWithALetterOrNumber = /[a-z0-9]$/.test(domain);
        if (!endsWithALetterOrNumber)
            errors.push('Must end in a letter or a number.');
        const thirtyCharacterOrLess = domain.length <= 30;
        if (!thirtyCharacterOrLess)
            errors.push('Must be 30 characters or less');
        if (errors.length > 0) {
            const errorString = errors.map((d, i) => `(${i + 1}: ${d}`).join(' ');
            const msg = `Validation errors: ${errorString}`;
            return Promise.reject(new Error(msg));
        }
        const url = `/app/dashboard/repositories/${domain}/exists`;
        return this.axios().get(url).then(res => {
            if (!res.data && !existingRepo)
                return Promise.reject(new Error(`${domain} is already in use`));
            return domain;
        });
    }
    /**
     * creates a prismic repository
     * @param args
     * @returns {Promise<AxiosResponse<string>>} - AxiosResponse containing the repository name
     */
    async createRepository(args) {
        this.debug('createRepository', JSON.stringify(args));
        const p = this.oauthAccessToken ? this.createRepositoryWithToken(args) : this.createRepositoryWithCookie(args);
        return p.then(res => {
            this.debug('createRepository:', res.status, res.statusText);
            return res;
        }).catch((error) => {
            var _a, _b;
            this.debug('ERROR: createRepository', error.message, (_a = error.response) === null || _a === void 0 ? void 0 : _a.status, (_b = error.response) === null || _b === void 0 ? void 0 : _b.statusText);
            throw error;
        });
    }
    async createRepositoryWithCookie({ domain, 
    // app, TODO: add app
    customTypes, signedDocuments, framework, }) {
        const signature = signedDocuments === null || signedDocuments === void 0 ? void 0 : signedDocuments.signature;
        const documents = (signedDocuments === null || signedDocuments === void 0 ? void 0 : signedDocuments.documents) ? JSON.stringify(signedDocuments.documents) : undefined;
        const data = Object.assign(Object.assign({ domain, plan: 'personal', isAnnual: 'false' }, ((customTypes === null || customTypes === void 0 ? void 0 : customTypes.length) ? { 'custom-types': JSON.stringify(customTypes) } : {})), { signature,
            documents, role: 'developer', framework });
        const retry = () => this.createRepositoryWithCookie({ domain, framework, customTypes, signedDocuments });
        const url = new URL(this.base);
        url.pathname = '/authentication/newrepository';
        url.searchParams.append('app', 'slicemachine');
        // const querystring = {app: 'slicemachine'}
        cli_ux_1.default.action.start('creating prismic repository');
        return this.axios({ maxRedirects: 0 }).post(url.toString(), data)
            .then(res => {
            cli_ux_1.default.action.stop();
            return res;
        })
            .catch((error) => {
            var _a, _b;
            cli_ux_1.default.action.stop(((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) || error.message);
            const status = Math.floor((((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.status) || 100) / 100);
            if (status === 4 || status === 3) {
                return this.reAuthenticate().then(retry);
            }
            throw error;
        });
    }
    async createRepositoryWithToken({ domain, 
    // app,
    customTypes, signedDocuments, framework, }) {
        const signature = signedDocuments === null || signedDocuments === void 0 ? void 0 : signedDocuments.signature;
        const documents = (signedDocuments === null || signedDocuments === void 0 ? void 0 : signedDocuments.documents) ? JSON.stringify(signedDocuments.documents) : undefined;
        const data = Object.assign(Object.assign({ access_token: this.oauthAccessToken, domain, plan: 'personal', isAnnual: 'false' }, ((customTypes === null || customTypes === void 0 ? void 0 : customTypes.length) ? { 'custom-types': JSON.stringify(customTypes) } : {})), { signature,
            documents, role: 'developer', framework });
        const url = new URL(this.base);
        url.hostname = `api.${url.hostname}`;
        url.pathname = '/management/repositories';
        url.searchParams.append('app', 'slicemachine');
        const retry = () => this.createRepositoryWithToken({ domain, framework, customTypes, signedDocuments });
        const address = url.toString();
        cli_ux_1.default.action.start('creating prismic repository');
        return this.axios().post(address, data)
            .then(res => {
            cli_ux_1.default.action.stop();
            return Object.assign(Object.assign({}, res), { data: res.data.domain });
        })
            .catch(error => {
            var _a;
            cli_ux_1.default.action.stop();
            const status = Math.floor((((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) || 100) / 100);
            if (status === 4 || status === 3) {
                return this.reAuthenticate().then(retry);
            }
            throw error;
        });
    }
}
exports.default = Prismic;
