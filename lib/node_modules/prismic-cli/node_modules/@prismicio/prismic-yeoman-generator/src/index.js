"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// see https://github.com/oclif/oclif/blob/master/src/generators/app.ts
const Generator = require("yeoman-generator");
Object.assign(Generator.prototype, require('yeoman-generator/lib/actions/install'));
const axios_1 = require("axios");
const tmp = require("tmp-promise");
const AdmZip = require("adm-zip");
const npath = require("path");
const cli_ux_1 = require("cli-ux");
const fs = require("fs");
const lookpath_1 = require("lookpath");
const ejs = require("ejs");
const lodash_1 = require("lodash");
const { snakelize } = require('sm-commons/utils/str');
const path = npath.posix;
function pascalCaseToSnakeCase(str) {
    return snakelize(str);
}
function toDescription(str) {
    return str.split(/(?=[A-Z0-9])/).join(' ');
}
function createStorybookId(str) {
    const camel = lodash_1.camelCase(str);
    return `_${camel[0].toUpperCase()}${camel.slice(1)}`;
}
class PrismicGenerator extends Generator {
    constructor(args, opts) {
        super(args, opts);
        this.path = opts.path;
        this.force = opts.force;
        this.domain = opts.domain;
        this.prismic = opts.prismic;
        this.pm = opts.pm;
        this.existingRepo = opts.existingRepo || false;
    }
    /**
     * Conditionally create a prismic repo.
     * @param {CreateRepositoryArgs} createRepositoryArgs - Parameters to uses when creating a repository.
     * @param {Boolean} [existingRepo = false] - skip creating a new prismic repository.
     * @returns {Promise<{data: String}>} - data being a conformation of the repository name.
     */
    async maybeCreatePrismicRepository(createRepositoryArgs, existingRepo = this.existingRepo) {
        if (existingRepo)
            return Promise.resolve({ data: createRepositoryArgs.domain || this.domain });
        return this.prismic.createRepository(createRepositoryArgs).then(res => {
            const url = new URL(this.prismic.base);
            url.host = `${res.data}.${url.host}`;
            this.log(`A new repository has been created at: ${url.toString()}`);
            return res;
        });
    }
    /**
     * Will infer to use yarn or npm and prompt the user to select a package manager when in doubt.
     * The result is assigned "this.pm" and return ed.
     * @example
     * ```ts
     * if(!this.pm) await this.promptForPackageManager()
     * ```
     *
     */
    async promptForPackageManager() {
        const hasYarn = await lookpath_1.lookpath('yarn');
        const usesYarn = fs.existsSync(this.destinationPath('yarn.lock'));
        if (!hasYarn) {
            this.pm = 'npm';
            return this.pm;
        }
        if (usesYarn) {
            this.pm = 'yarn';
            return this.pm;
        }
        return this.prompt({
            type: 'list',
            name: 'pm',
            message: 'package manager',
            choices: ['npm', 'yarn'],
        }).then(res => {
            this.pm = res.pm;
            return res.pm;
        });
    }
    /**
     * Downloads a zip file and extracts it to yeoman's mem-fs.
     * Mainly use in the theme command/generator
     *
     * @param {string} source - the full url to a zip file with a template repo
     * @param {?string} innerFolder - the folder to extract from the downloaded zip file
     *
     * @example
     * ```ts
     * this.downloadAndExtractZipFrom('https://github.com/prismicio/fake-theme/archive/master.zip, 'fake-theme-master')
     * ```
     */
    async downloadAndExtractZipFrom(source, innerFolder) {
        const tmpFile = await tmp.file();
        const tmpDir = await tmp.dir();
        const progressBar = cli_ux_1.default.progress({
            format: 'Downloading Template | {bar} {percentage}% | ETA {eta}s',
        });
        return axios_1.default.get(source, {
            responseType: 'stream',
        })
            .then(res => {
            const total = res.headers['content-length'];
            let count = 0;
            const startProgress = () => total ? progressBar.start(total, count) : cli_ux_1.default.action.start('Downloading starter project');
            const updateProgress = (count) => total ? progressBar.update(count) : undefined;
            const stopProgress = () => total ? progressBar.stop() : cli_ux_1.default.action.stop('Download complete');
            startProgress();
            return new Promise((resolve, reject) => {
                const writeStream = fs.createWriteStream(tmpFile.path);
                res.data.on('data', chunk => {
                    count += chunk.length;
                    updateProgress(count);
                });
                res.data.pipe(writeStream)
                    .on('finish', () => {
                    stopProgress();
                    return resolve(tmpFile);
                })
                    .on('error', error => {
                    stopProgress();
                    return reject(error);
                });
            });
        }).then(() => {
            const zip = new AdmZip(tmpFile.path);
            zip.extractAllTo(tmpDir.path);
            return tmpFile.cleanup();
        }).then(() => {
            const location = innerFolder ? path.join(tmpDir.path, innerFolder) : tmpDir.path;
            this.fs.copy(location, this.destinationPath(), { globOptions: { dot: true } });
            return this;
        });
    }
    handleOldCustomTypes(customTypesDirectory) {
        const pathToCustomTypesMetaInfo = this.destinationPath(customTypesDirectory, 'index.json');
        const customTypesMetaInfoAsString = this.fs.read(pathToCustomTypesMetaInfo, { defaults: '[]' });
        const customTypesMetaInfo = JSON.parse(customTypesMetaInfoAsString);
        const customTypes = customTypesMetaInfo.map((meta) => {
            const location = this.destinationPath(customTypesDirectory, meta.value);
            const json = this.fs.readJSON(location);
            return Object.assign(Object.assign({}, meta), { value: json });
        });
        return customTypes;
    }
    handleNewCustomTypes(customTypesDirectory) {
        const pathToFolder = this.destinationPath(customTypesDirectory);
        const toIgnore = path.join(pathToFolder, 'index.json');
        const customTypes = [];
        this.env.sharedFs.each(file => {
            if (file.path.startsWith(pathToFolder) && file.basename === 'index.json' && file.path !== toIgnore) {
                const ct = this.readDestinationJSON(file.path);
                const { json, label } = ct, meta = tslib_1.__rest(ct
                // renaming these properties for now
                , ["json", "label"]);
                // renaming these properties for now
                customTypes.push(Object.assign(Object.assign({ name: label }, meta), { value: json }));
            }
        });
        return customTypes;
    }
    /**
     * Read custom-types from mem-fs. This is used to send custom types during repo creation
     *
     * @param {?string} maybeCustomTypesDirectory - the directory to read the custom types from defaults to 'custom_types'
     * @returns {Array<CustomType>} - or an empty array
     *
     * @example
     * ```ts
     * this.downloadAndExtractZipFrom('https://github.com/prismicio/fake-theme/archive/master.zip, 'fake-theme-master')
     * const customTypes = this.readCustomTypesFrom('custom_types')
     * this.prismic.createRepository({ domain: this.domain, customTypes })
     * ```
     */
    readCustomTypesFrom(maybeCustomTypesDirectory) {
        const customTypesDirectory = maybeCustomTypesDirectory || 'customtypes';
        const maybeNewFormat = this.handleNewCustomTypes(customTypesDirectory);
        if (maybeNewFormat.length > 0)
            return maybeNewFormat;
        return this.handleOldCustomTypes(maybeCustomTypesDirectory || 'custom_types');
    }
    /**
     * Used in the theme generator,
     * This reads and formats the documents in the `documentsDirectory` so they can be sent to prismic during repo-creation.
     *
     * @param {?string} documentsDirectory - defaults to 'documents'
     * @returns {Documents} or undefined
     *
     * @example
     * ```ts
     * await this.downloadAndExtractZipFrom('https://github.com/prismicio/fake-theme/archive/master.zip, 'fake-theme-master')
     * const customTypes = this.readCustomTypesFrom('custom_types')
     * const documents = this.readDocumentsFrom('documents')
     * await this.prismic.createRepository({ domain: this.domain, customTypes, documents })
     * ```
     */
    readDocumentsFrom(documentsDirectory = 'documents') {
        const pathToDocuments = this.destinationPath(documentsDirectory);
        const pathToSignatureFile = path.join(pathToDocuments, 'index.json');
        if (this.fs.exists(pathToSignatureFile) === false) {
            return;
        }
        const documents = {};
        this.env.sharedFs.each(file => {
            if (file.path.startsWith(pathToDocuments) && file.basename !== 'index.json') {
                const name = file.stem;
                const value = this.fs.readJSON(file.relative);
                documents[name] = value;
            }
        });
        const signatureFile = this.fs.read(path.join(pathToDocuments, 'index.json'));
        const { signature } = JSON.parse(signatureFile);
        return {
            signature,
            documents,
        };
    }
    branchFromUrl(source) {
        const lastSlash = source.lastIndexOf('/');
        const fileExtension = source.lastIndexOf('.');
        return source.substring(lastSlash + 1, fileExtension);
    }
    gitRepoFromUrl(source) {
        const url = new URL(source);
        const paths = url.pathname.split('/').filter(_ => _);
        return paths[1];
    }
    /**
     * Used in the theme command and generators that use github urls so the inner folder of the downloaded zip can be extracted to mem-fs
     *
     * @param {string} source - a url to a zip file on github.
     * @returns a string that should be the inner folder of the zip file.
     * @example
     * ```ts
     * const url = 'https://github.com/prismicio/fake-theme/archive/master.zip'
     * this.innerFolderFromGitRepo(url) // fake-theme-master
     * ```
     */
    innerFolderFromGitRepo(source) {
        const branch = this.branchFromUrl(source);
        const repo = this.gitRepoFromUrl(source);
        return `${repo}-${branch}`;
    }
    copySliceTemplate(library, sliceName) {
        const pathToLib = this.destinationPath(path.join(library, sliceName));
        const sliceId = pascalCaseToSnakeCase(sliceName);
        const description = toDescription(sliceName);
        const slicesDirectoryPath = path.join('.slicemachine', 'assets', library, sliceName);
        const pathToComponentFromStory = path.relative(slicesDirectoryPath, path.join(library, sliceName));
        const pathToModelFromStory = path.join(pathToComponentFromStory, 'model.json');
        const mocksTemplate = fs.readFileSync(this.templatePath('library/slice/mocks.json'), 'utf-8');
        const mocksAsString = ejs.render(mocksTemplate, { sliceId, sliceName, description });
        const mocks = JSON.parse(mocksAsString).map((d) => (Object.assign({ id: createStorybookId(d.variation || d.name) }, d)));
        this.fs.copyTpl(this.templatePath('library/slice/**'), pathToLib, { sliceName, sliceId: sliceId, description, pathToComponentFromStory, pathToModelFromStory, mocks, componentTitle: `${library}/${sliceName}` });
        /* for the slicemachine update */
        this.moveDestination(path.join(pathToLib, 'index.stories.*'), slicesDirectoryPath);
        this.moveDestination(path.join(pathToLib, 'mocks.json'), path.join(slicesDirectoryPath, 'mocks.json'));
    }
}
exports.default = PrismicGenerator;
