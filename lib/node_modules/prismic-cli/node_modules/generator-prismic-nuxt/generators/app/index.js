"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const prismic_yeoman_generator_1 = require("@prismicio/prismic-yeoman-generator");
const inquirer = require("inquirer");
const NuxtPrompts = require('create-nuxt-app/lib/prompts');
const saoSettings = require('create-nuxt-app/lib/saofile');
const evaluate = (exp, data) => {
    /* eslint-disable no-new-func */
    /* eslint-disable no-console */
    const fn = new Function('data', `with (data) { return ${exp} }`);
    try {
        return fn(data);
    }
    catch (error) {
        console.error(error.stack);
        console.error(`Error when evaluating filter condition: ${exp}`);
    }
};
class Nuxt extends prismic_yeoman_generator_1.default {
    constructor() {
        super(...arguments);
        this.answers = {};
        this.sao = { opts: {} };
    }
    /**
     * initializing - Your initialization methods (checking current project state, getting configs, etc)
     * prompting - Where you prompt users for options (where you’d call this.prompt())
     * configuring - Saving configurations and configure the project (creating .editorconfig files and other metadata files)
     * default - If the method name doesn’t match a priority, it will be pushed to this group.
     * writing - Where you write the generator specific files (routes, controllers, etc)
     * conflicts - Where conflicts are handled (used internally)
     * install - Where installations are run (npm, bower)
     * end - Called last, cleanup, say good bye, etc
     */
    async initializing() {
        this.destinationRoot(this.path);
    }
    async prompting() {
        // ask normal nuxt questions from create-nuxt-app/lib/prompts
        const nuxtPrompts = NuxtPrompts.map(p => {
            if (p.name === 'name')
                return Object.assign(Object.assign({}, p), { default: this.domain });
            // do the same for github user name
            if (p.name === 'gitUsername')
                return Object.assign(Object.assign({}, p), { default: async () => {
                        try {
                            const username = await this.user.github.username();
                            return username;
                        }
                        catch (_a) {
                            return this.user.git.name() || this.user.git.email();
                        }
                    } });
            return p;
        });
        const prompts = [...nuxtPrompts, {
                name: 'slicemachine',
                type: 'confirm',
                default: true,
                message: 'Slice Machine',
            }];
        this.answers = await inquirer.prompt(prompts);
    }
    async configuring() {
        this.config.set('framework', 'nuxt');
        const opts = Object.assign({ framework: 'nuxt', domain: this.domain, prismic: this.prismic, force: this.force, pm: this.answers.pm, existingRepo: this.existingRepo }, this.options);
        if (this.answers.slicemachine) {
            this.composeWith('prismic-nuxt:slicemachine', opts);
            this.composeWith('prismic-nuxt:create-slice', opts);
            this.composeWith('prismic-nuxt:storybook', opts);
        }
    }
    async writing() {
        // template data to be passed to copyTmp
        const templateData = saoSettings.templateData.bind(this)();
        this.outDir = this.destinationPath();
        const actions = saoSettings.actions.bind(this)();
        // load the files into mem-fs
        actions.forEach(action => {
            switch (action.type) {
                case 'add': {
                    if (action.files === 'package.json' && action.templateDir === this.outDir) {
                        return;
                    }
                    const filters = action.filters || {};
                    const ignore = Object.entries(filters).reduce((acc, [file, condition,]) => {
                        const pathToFile = path.join(action.templateDir, file);
                        if (typeof condition === 'string') {
                            const shouldIgnore = evaluate(condition, this.answers);
                            return shouldIgnore ? acc : [...acc, pathToFile];
                        }
                        return condition ? [...acc, pathToFile] : acc;
                    }, ['**/nuxt/node_modules/**']);
                    const fromPath = path.join(action.templateDir, action.files);
                    return this.fs.copyTpl(fromPath, this.destinationPath(), Object.assign(Object.assign({}, this.answers), templateData), {}, { globOptions: { ignore } });
                }
                case 'move': {
                    return Object.entries(action.patterns).forEach(([from, to,]) => {
                        this.existsDestination(from) && this.moveDestination(from, to);
                    });
                }
                case 'modify': {
                    if (!action.handler)
                        return;
                    const files = (typeof action.files === 'string') ? [action.files] : [...action.files];
                    return files.forEach(async (fileName) => {
                        const isJson = fileName.endsWith('.json');
                        const pathToFile = this.destinationPath(fileName);
                        const content = isJson ? this.readDestinationJSON(fileName) : this.readDestination(fileName);
                        const result = await action.handler(content, fileName);
                        this.deleteDestination(fileName);
                        if (isJson) {
                            this.writeDestinationJSON(pathToFile, result, undefined, 2);
                        }
                        else {
                            this.writeDestination(pathToFile, result);
                        }
                    });
                }
                case 'remove': {
                    let patterns = [];
                    if (typeof action.files === 'string') {
                        patterns = [action.files];
                    }
                    else if (Array.isArray(action.files)) {
                        patterns = action.files;
                    }
                    else if (typeof action.files === 'object') {
                        patterns = Object.keys(action.files).reduce((acc, [file, condition]) => {
                            if (typeof condition === 'string') {
                                const shouldIgnore = evaluate(condition, this.answers);
                                return shouldIgnore ? acc : [...acc, file];
                            }
                            return condition ? [...acc, file] : acc;
                        }, []);
                    }
                    return patterns.map(file => this.deleteDestination(file));
                }
            }
        });
        // doing the modifications see here: https://sao.vercel.app/saofile.html#actions
        // add: convert filters to https://github.com/mrmlnc/fast-glob#options-1 filters become ingore in the globOptions
        if (!this.answers.slicemachine) {
            this.maybeCreatePrismicRepository({ domain: this.domain, framework: 'nuxt' }, this.existingRepo);
        }
    }
    install() {
        if (this.answers.pm === 'yarn') {
            this.yarnInstall();
        }
        else {
            this.npmInstall();
        }
    }
}
exports.default = Nuxt;
